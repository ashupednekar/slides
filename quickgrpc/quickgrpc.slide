# Quick gRPC

Ashu Pednekar 
21 Sep 2024



ashupednekar49@gmail.com

https://github.com/ashupednekar

https://www.linkedin.com/in/ashutosh-pednekar-434b52103/

## Welcome to Quick gRPC

Ready to jump ship WSGI and join the microservices party? Let‚Äôs gRPC and roll!

.image one.jpg 500 1000

## But REST api's are great... Why bother?

<br><br>

.html two.html

## Are they though? ü´§

<br><br>

.html three.html


## So what exactly is gRPC

<br>
gRPC is like a supercharged intercom system for your microservices. üöÄ
<br><br>

- **Protocol:** Think of HTTP/2 as the speedy highway for your data, zipping it around efficiently.
- **Serialization:** Protocol Buffers (protobuf) are like a universal translator, helping different services speak the same language.
- **Language Support:** Supports multiple languages, so you can have a polyglot party and everyone gets along!
- **Streaming:** Handles requests and responses like a pro, even when they‚Äôre long-winded or chatty.

## Protobuf

.html protobuf.html

## Let's build one

We'll build a simple crud service 

Let's define the protobud in a `.proto` file

We start a proto file by specifying the syntax version, like so

.code crud0.proto

Here's a link to the protobuf definition

.image qrcode_protobuf.dev.png 200 200
.link https://protobuf.dev

## Let's first start with the services
<br>

.code crud2.proto

<br><br>
The service handles creating, listing, retrieving, updating, and deleting employee records.
<br><br>
Handles everything from adding a new hire to giving them the boot, with input as EmployeeInp and output as Employee‚Äîbecause even computers need paperwork.

## Now let's define the messages 

.code crud1a.proto

## Create and retieve/update will need seperate messages

.code crud1b.proto


## Finally, the list message

.code crud1c.proto


## What next?

This is how it works

When working with protoc, think of it as the translator who turns your .proto files into code that your project can actually speak to. 

`protoc --<language>_out=<output_directory> <file>.proto` does the trick, generating all the gRPC wrapper code you‚Äôll need. 


Here's a link to the docs 

.image qrcode_grpc.io.py.png 200 200
.link https://grpc.io/docs/languages/python/


## So what's quickgRPC ?

It's a simple tool that makes this process much nicer, where you just give it your proto and it spits out boilerplate server and client skeletal code

Another thing it does is put the protoc generated code in `site packages` so that you don't have to ship it along with your server code.

*Note: This is a simple tool I wrote a few years ago. Suggestions/improvements welcome as PRs!*
<hr>
Here's a link to the docs

.image qrcode_ashupednekar.github.io.png 150 150
.link https://ashupednekar.github.io/quickgrpc/Getting%20Started/

## Demo time üòÑ

.video demogen.mov video/mp4 580 1000

## So far...

We wrote out proto file, with rpc's and their corresponding mmessages

Used the `create_grpc_service` command to generate the boilerplate code we'll need

Looked at proto file validations passed through from protoc

<br>

**Few considerations**

The quickgrpc library currently makes a few assumptions
- proto file name same as the service name, with the latter being in Title case
- single service in proto file

These things can change, if there's enough interest... maybe a go/rust rewrite/language support

## Let's write the rpc logic, starting with Create

.video rpclogiccreate.mov video/mp4 580 1000

## Summary

<br><br><br><br>

We're using a python dictionary as our db

Adding empoyees to the db as they come in

Note the `pb2` snippets, this is where we interact with code generated by protoc

## Listing these employees

.video rpclogiclist.mov video/mp4 580 1000

## Summary

<br><br><br><br>

Since our 'DB' is just a python dict, we need to convert that to the pb2 compatible object, that's what this is

Note: none of these are best practices for business logic, just an illustration

## Let's quickly right retrieve and delete

.video rpclogicredel.mov video/mp4 580 1000


## Now let's update the tests

.video demotest.mov video/mp4 580 1000


## Voila

.video voilaa.mov video/mp4 580 1000

## More stuff gRPC can do

What we've covered so far is only unary, which is the most analogous to REST apis

<br>

gRPC also supports

<br>

- **client side streaming**: the client can keep sending data and the server will respond when it's ready... e.g. KYC
- **server side, i.e. SSE**: client sends one request and the server keeps yielding results, e.g. progress bars
- **bi-directional**



## Summary

As you saw, there were a few bugs in our service
- the employee_inp was being passed an id in the unittest. We changed the service to use dict length plus one instead
- the list extend call was not being made on `.employees` which is the repeated message as per our protobuf.
- We can also do client, server side or two way byte streaming by chaning proto and making our tests/server functions async

<br>
That's it! üòÅ
<br><br>
<hr><br>

note: gRPC is not a silver bullet, it's meant for service to service communication alongside pubsub, most browsers don't support it directly
